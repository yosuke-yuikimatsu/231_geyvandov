# Подробное решение задач

---

## 1. Преобразование десятичных чисел в 6-битные двоичные

### **Беззнаковые числа**:
- **0**:  
  Двоичное представление: `000000` (0 в любой системе счисления).
  
- **13**:  
  1. Делим 13 на 2:  
     - 13 ÷ 2 = 6 (остаток **1**)  
     - 6 ÷ 2 = 3 (остаток **0**)  
     - 3 ÷ 2 = 1 (остаток **1**)  
     - 1 ÷ 2 = 0 (остаток **1**)  
  2. Записываем остатки в обратном порядке: `1101`.  
  3. Дополняем до 6 бит: `001101`.

- **24**:  
  1. Делим 24 на 2:  
     - 24 ÷ 2 = 12 (остаток **0**)  
     - 12 ÷ 2 = 6 (остаток **0**)  
     - 6 ÷ 2 = 3 (остаток **0**)  
     - 3 ÷ 2 = 1 (остаток **1**)  
     - 1 ÷ 2 = 0 (остаток **1**)  
  2. Результат: `11000`.  
  3. Дополняем до 6 бит: `011000`.

- **63**:  
  1. Максимальное 6-битное число: `111111` (2⁶ - 1 = 63).

---

### **Знаковые числа (дополнительный код)**:
- **16**:  
  Положительные числа кодируются как обычные двоичные:  
  - 16 = 2⁴ → `010000`.

- **-2**:  
  1. Представляем 2 в двоичном виде: `000010`.  
  2. Инвертируем биты: `111101`.  
  3. Добавляем 1: `111101 + 1 = 111110`.  
  Результат: `111110`.

- **31**:  
  Максимальное положительное 6-битное число:  
  - 31 = 2⁵ - 1 → `011111`.

- **-32**:  
  Минимальное отрицательное 6-битное число:  
  - В дополнительном коде: `100000`.

---

## 2. Преобразование 6-битных значений в десятичные

### **Формулы**:
- **Беззнаковое**:  
$\text{Decimal} = b_5 \cdot 32 + b_4 \cdot 16 + b_3 \cdot 8 + b_2 \cdot 4 + b_1 \cdot 2 + b_0 \cdot 1$.

- **Знаковое (дополнительный код)**:  
  Если старший бит $b_5 = 1$:  
  $\text{Decimal} = -(32 - (b_4 \cdot 16 + b_3 \cdot 8 + b_2 \cdot 4 + b_1 \cdot 2 + b_0 \cdot 1)) $.

### **Примеры**:
- **000101**:  
  - Беззнаковое: $ 0 \cdot 32 + 0 \cdot 16 + 0 \cdot 8 + 1 \cdot 4 + 0 \cdot 2 + 1 \cdot 1 = 5 $.  
  - Знаковое: Старший бит 0 → число положительное: **5**.

- **101011**:  
  - Беззнаковое: $ 1 \cdot 32 + 0 \cdot 16 + 1 \cdot 8 + 0 \cdot 4 + 1 \cdot 2 + 1 \cdot 1 = 43 $.  
  - Знаковое: $ -(32 - (0 \cdot 16 + 1 \cdot 8 + 0 \cdot 4 + 1 \cdot 2 + 1 \cdot 1)) = -21 $.

- **111111**:  
  - Беззнаковое: 63.  
  - Знаковое: $ -(32 - 31) = -1 $.

- **100000**:  
  - Беззнаковое: 32.  
  - Знаковое: -32 (минимальное значение).

---

## 3. Преобразование десятичных чисел в 8-битные HEX

### **Алгоритм**:
1. Перевести число в двоичное (8 бит).  
2. Разбить на два полубайта (4 бита).  
3. Каждый полубайт перевести в HEX.

### **Примеры**:
- **7**:  
  - Двоичное: `00000111`.  
  - Полубайты: `0000` (0) и `0111` (7).  
  - HEX: `0x07`.

- **240**:  
  - Двоичное: `11110000`.  
  - Полубайты: `1111` (F) и `0000` (0).  
  - HEX: `0xF0`.

- **171**:  
  - Двоичное: `10101011`.  
  - Полубайты: `1010` (A) и `1011` (B).  
  - HEX: `0xAB`.

- **126**:  
  - Двоичное: `01111110`.  
  - Полубайты: `0111` (7) и `1110` (E).  
  - HEX: `0x7E`.

---

## 4. Преобразование HEX в 8-битные двоичные

### **Правило**:
Каждая HEX-цифра кодируется 4 битами:
- `0` → `0000`
- `1` → `0001`
- `2` → `0010`
- ...
- `F` → `1111`.

### **Примеры**:
- **0x3C**:  
  - `3` → `0011`, `C` → `1100`.  
  - Результат: `00111100`.

- **0x7E**:  
  - `7` → `0111`, `E` → `1110`.  
  - Результат: `01111110`.

- **0xFF**:  
  - `F` → `1111`.  
  - Результат: `11111111`.

- **0xA5**:  
  - `A` → `1010`, `5` → `0101`.  
  - Результат: `10100101`.

---

## 5. Инверсия двоичных чисел (дополнительный код)

### **Алгоритм**:
1. Инвертировать все биты.  
2. Прибавить 1 к результату.

### **Примеры**:
- **00111100**:  
  1. Инверсия: `11000011`.  
  2. Добавляем 1: `11000011 + 1 = 11000100`.

- **01111110**:  
  1. Инверсия: `10000001`.  
  2. Добавляем 1: `10000001 + 1 = 10000010`.

- **11111111**:  
  1. Инверсия: `00000000`.  
  2. Добавляем 1: `00000000 + 1 = 00000001`.

- **10100101**:  
  1. Инверсия: `01011010`.  
  2. Добавляем 1: `01011010 + 1 = 01011011`.

---

## 6. Расположение байтов в памяти (Endianness)

- **Big-Endian**:  
  Байты записываются от старшего к младшему.  
  Пример для `0xDEADBEEF`:  
  - Память: `DE AD BE EF`.

- **Little-Endian**:  
  Байты записываются от младшего к старшему.  
  Пример для `0xDEADBEEF`:  
  - Память: `EF BE AD DE`.

---

## 7. Знаковое и беззнаковое расширение

### **Правила**:
- **Знаковое расширение**: Копируется старший бит.  
- **Беззнаковое расширение**: Дополняется нулями.

### **Примеры**:
- **7** (5-бит: `00111`):  
  - Знаковое: `00000111`.  
  - Беззнаковое: `00000111`.

- **15** (5-бит: `01111`):  
  - Знаковое: `00001111`.  
  - Беззнаковое: `00001111`.

- **-16** (5-бит: `10000`):  
  - Знаковое: `11110000` (копируется старший бит `1`).  
  - Беззнаковое: Неприменимо (отрицательные числа в беззнаковом формате не кодируются).

- **-5** (5-бит: `11011`):  
  - Знаковое: `11111011`.  
  - Беззнаковое: `00011011` (но это некорректно для отрицательных чисел).

---

## 8. Сложение 4-битных чисел

### **Правила**:
- **Беззнаковое сложение**: Если результат превышает 15 (1111), происходит переполнение.  
- **Знаковое сложение**: Используется дополнительный код.

### **Примеры**:
- **7 (0111) + 9 (1001)**:  
  - Беззнаковое:  
    `0111 + 1001 = 10000`.  
    Результат в 4 битах: `0000` (переполнение).  

- **4 (0100) + (-5) (1011)**:  
  - Знаковое:  
    `0100 + 1011 = 1111`.  
    Декодируем `1111` (дополнительный код):  
    - Инверсия: `0000`, добавляем 1 → `0001`.  
    - Результат: **-1**.

---

## 9. Объяснение трюка с XOR

### **Алгоритм**:
1. `x = x ^ y`: Сохраняет различие битов между `x` и `y`.  
2. `y = x ^ y`:  
   - Подставляем `x` из шага 1: `y = (x ^ y) ^ y`.  
   - По свойству XOR: `y = x ^ (y ^ y) = x ^ 0 = x`.  
3. `x = x ^ y`:  
   - Теперь `y` содержит исходное `x`: `x = (x ^ y) ^ x`.  
   - По свойству XOR: `x = y ^ (x ^ x) = y ^ 0 = y`.

### **Пример**:
- Исходные значения: `x = 5 (0101)`, `y = 3 (0011)`.  
  1. `x = 0101 ^ 0011 = 0110`.  
  2. `y = 0110 ^ 0011 = 0101` (теперь `y = 5`).  
  3. `x = 0110 ^ 0101 = 0011` (теперь `x = 3`).

---

## 10. Объяснение битовых трюков

### **1. x & (x - 1)**  
**Эффект**: Обнуление самого правого установленного бита (1 → 0).  

**Доказательство**:  
Пусть двоичное представление числа `x` имеет вид:  
`x = A 1 0...0`,  
где:  
- `A` — произвольная битовая последовательность слева от правой 1,  
- `1` — самый правый установленный бит,  
- `0...0` — `k` нулей справа от него.  

Тогда:  
`x - 1 = A 0 1...1` (вычитание 1 превращает правую 1 в 0, а все `k` нулей справа в 1).  

Применим операцию **AND** и получим:  

`A 0 0 0 ... 0`

Результат: `A 0 0...0` — самый правый 1-бит обнулен.

---

### **2. x | (x + 1)**  
**Эффект**: Установка самого правого нулевого бита (0 → 1).  

**Доказательство**:  
Пусть двоичное представление числа `x` имеет вид:  
`x = B 0 C`,  
где:  
- `B` — произвольная битовая последовательность слева от правого 0,  
- `0` — самый правый нулевой бит,  
- `C` — последовательность единиц  

Тогда:  
`x + 1 = B 1 0...0` (прибавление 1 превращает правый 0 в 1, а все биты в `C` в 0).  

Применим операцию **OR** и получим:  

`B 1 C`

### **3. x | (x - 1)**  
**Эффект**: Установка всех нулевых битов **справа** от самой правой 1.  

**Доказательство**:  
Пусть двоичное представление числа `x` имеет вид:  
`x = D 1 0...0`,  
где:  
- `D` — произвольная битовая последовательность слева от правой 1,  
- `1` — самая правая 1,  
- `0...0` — `k` нулей справа от нее.  

Тогда:  
`x - 1 = D 0 1...1` (вычитание 1 превращает правую 1 в 0, а все `k` нулей справа в 1).  

Применим операцию **OR** и получим:

`D 1 1 ... 1`